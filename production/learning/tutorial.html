<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
    <title>Jsonnet - The Data Templating Language</title>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
    <meta name="keywords" content="Jsonnet, JSON, YAML, language, configuration, configuration language, functional, declarative, lazy, structured, elegant, semantics, clean, mixins, inheritance, template, expansion, expand" />
    <meta name="description" content="A powerful DSL for elegant description of JSON data." />
    <meta name="viewport" content="width=576">

    <link rel="icon" type="image/png" href="/favicon.png" />

    <!-- MathJax (for semantics) -->
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX","output/HTML-CSS"],
        displayAlign: "left",
        imageFont: null,
    });
    </script>
    <script type="text/javascript" src="/third_party/MathJax-2.7.2/MathJax.js"></script>


    <!-- Google Analytics -->
    <script type="text/javascript">
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-53570216-1', 'auto');
      ga('send', 'pageview');
    </script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:400italic,600italic,700italic,400,600,700" rel="stylesheet" type="text/css">

    <!-- CodeMirror -->
    <link rel="stylesheet" href="/third_party/CodeMirror/lib/codemirror.css">
    <script src="/third_party/js-yaml/dist/js-yaml.min.js"></script>
    <script src="/third_party/CodeMirror/lib/codemirror.js"></script>
    <script src="/third_party/CodeMirror/mode/yaml/yaml.js"></script>
    <script src="/third_party/CodeMirror/addon/edit/matchbrackets.js"></script>
    <script src="/js/codemirror-mode-jsonnet.js"></script>

    <!-- Executing Jsonnet -->
    <script src="/js/libjsonnet.js"></script>
    <script src="/js/demo.js"></script>

    <!-- Navigation menus -->
    <script src="/js/menu.js"></script>

    <!-- jsonnet.org stylesheet -->
    <link rel="stylesheet" type="text/css" href="/css/doc.css" />
    <link rel="stylesheet" media="print" href="/css/desktop.css">
    <!-- The extra 16px is to account for the scrollbar, which is not always included. -->
    <link rel="stylesheet" media="screen and (min-width: 1296px)" href="/css/desktop.css">
    <link rel="stylesheet" media="screen and (max-width: 1295px) and (min-width: 720px)" href="/css/cellphone.css">
    <link rel="stylesheet" media="screen and (max-width: 719px)" href="/css/cellphone-small.css">
</head>

<body>

<div id=header>
  <div class=header2>
    <a id=header-logo class=header-element href="/"><img src="/img/isologo.svg"></a>
    <a id=header-title class=header-element href="/">Jsonnet</a>

    <div class="header-element menu">
      <div onclick='menu_open_popup(find_enclosing_menu(this))' onmouseover='menu_open_popup(find_enclosing_menu(this))' onmouseout='menu_leave()'>
        Learning
      </div>
      <div class=pop-up onmouseover='menu_open_popup(find_enclosing_menu(this))' onmouseout='menu_leave()'>
        <a href="/learning/tutorial.html">Tutorial</a>
        <a href="/learning/getting_started.html">Getting Started</a>
        <a href="/learning/tools.html">Tools</a>
        <a href="/learning/community.html">Community</a>
      </div>
    </div>

    <div class="header-element menu">
      <div onclick='menu_open_popup(find_enclosing_menu(this))' onmouseover='menu_open_popup(find_enclosing_menu(this))' onmouseout='menu_leave()'>
        Reference
      </div>
      <div class=pop-up onmouseover='menu_open_popup(find_enclosing_menu(this))' onmouseout='menu_leave()'>
        <a href="/ref/language.html">Language Reference</a>
        <a href="/ref/stdlib.html">Standard Library</a>
        <a href="/ref/spec.html">Specification</a>
        <a href="/ref/bindings.html">Bindings</a>
      </div>
    </div>

    <div class="header-element menu">
      <div onclick='find_enclosing_menu(menu_open_popup(this))' onmouseover='menu_open_popup(find_enclosing_menu(this))' onmouseout='menu_leave()'>
        Articles
      </div>
      <div class=pop-up onmouseover='menu_open_popup(find_enclosing_menu(this))' onmouseout='menu_leave()'>
        <a href="/articles/fractal.1.html">Terraform & Packer</a>
        <a href="/articles/kubernetes.html">Kubernetes</a>
        <a href="/articles/output-formats.html">Output Formats</a>
        <a href="/articles/design.html">Design Rationale</a>
        <a href="/articles/comparisons.html">Comparisons</a>
      </div>
    </div>
    <a id=groupsmark class=header-element href="https://groups.google.com/forum/#!forum/jsonnet"></a>
    <a id=githubmark class=header-element href="http://github.com/google/jsonnet"></a>
    <a id=gomark class=header-element href="http://github.com/google/go-jsonnet"></a>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <h1 id="tutorial">Tutorial</h1>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        Let's explore the various features in Jsonnet, and mix some cocktails.  All example codes
        can be editted, allowing you to experience the language interactively.  If you're looking at
        Jsonnet for the first time, this is the right place to be.  For help using the
        implementation, see <a href="getting_started.html">getting started</a>.  For a detailed
        systematic overview of the language, check out the <a
        href="/ref/language.html">reference</a>.
      </p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <h2 id="syntax">Syntax</h2>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        Any <a href="https://json.org">JSON</a> document is a valid Jsonnet program, so we'll focus
        on what Jsonnet adds to JSON.  Let's start with an example that does not involve any
        computation but uses new syntax.
      </p>
      <ul>
        <li>Fields that happen to be valid identifiers have no quotes</li>
        <li><i>Trailing</i> commas at the end of arrays / objects</li>
        <li>Comments</li>
        <li>
          String literals use <code>"</code> or <code>'</code>.  The single quote is easier on the
          eyes but either can be used to avoid escaping the other, e.g. <code>"Farmer's Gin"</code>
          instead of <code>'Farmer\'s Gin'</code>.
        </li>
        <li>
          Text blocks <code>|||</code> allow verbatim text across multiple lines.
        </li>
        <li>
          Verbatim strings <code>@'foo'</code> and <code>@"foo"</code> are for single lines.
        </li>
      </ul>
      <p>
        Using the interactive demo below, try modifying the strings / quantities.  Try adding a "Dry
        Manhattan" which uses dry red vermouth and is garnished with a lemon slice.
      </p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="inverse hgroup">
  <div class=hgroup-inline>
    <div class="tab-window-input" id="syntax-input">
      <div class="tab-header">
      </div>
      <textarea id=syntax-jsonnet>
/* A C-style comment. */
# A Python-style comment.
{
  cocktails: {
    // Ingredient quantities are in fl oz.
    'Tom Collins': {
      ingredients: [
        { kind: "Farmer's Gin", qty: 1.5 },
        { kind: 'Lemon', qty: 1 },
        { kind: 'Simple Syrup', qty: 0.5 },
        { kind: 'Soda', qty: 2 },
        { kind: 'Angostura', qty: 'dash' },
      ],
      garnish: 'Maraschino Cherry',
      served: 'Tall',
      description: |||
        The Tom Collins is essentially gin and
        lemonade.  The bitters add complexity.
      |||,
    },
    Manhattan: {
      ingredients: [
        { kind: 'Rye', qty: 2.5 },
        { kind: 'Sweet Red Vermouth', qty: 1 },
        { kind: 'Angostura', qty: 'dash' },
      ],
      garnish: 'Maraschino Cherry',
      served: 'Straight Up',
      description: @'A clear \ red drink.',
    },
  },
}

      </textarea>
    </div>
    <div class="bigarrow">➡</div>
    <div class="tab-window-output" id="syntax-output">
      <div class="tab-header">
        <div class=selected onclick="tab_click(this, 'syntax-json-output')">output.json</div>
      </div>
      <textarea readonly class="selected code-json" id="syntax-json-output">
{
  "cocktails": {
    "Manhattan": {
      "description": "A clear \\ red drink.",
      "garnish": "Maraschino Cherry",
      "ingredients": [
        {
          "kind": "Rye",
          "qty": 2.5
        },
        {
          "kind": "Sweet Red Vermouth",
          "qty": 1
        },
        {
          "kind": "Angostura",
          "qty": "dash"
        }
      ],
      "served": "Straight Up"
    },
    "Tom Collins": {
      "description": "The Tom Collins is essentially gin and\nlemonade.  The bitters add complexity.\n",
      "garnish": "Maraschino Cherry",
      "ingredients": [
        {
          "kind": "Farmer's Gin",
          "qty": 1.5
        },
        {
          "kind": "Lemon",
          "qty": 1
        },
        {
          "kind": "Simple Syrup",
          "qty": 0.5
        },
        {
          "kind": "Soda",
          "qty": 2
        },
        {
          "kind": "Angostura",
          "qty": "dash"
        }
      ],
      "served": "Tall"
    }
  }
}

      </textarea>
    </div>
    <script>
      demo(
        'syntax-input',
        {
          'syntax-jsonnet': 'syntax.jsonnet',
        },
        'syntax.jsonnet',
        'syntax-output',
        false,
        false
      );
    </script>
    <div style="clear: both"></div>
  </div>
</div>



<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <h2 id="variables">Variables</h2>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        Variables are the simplest way to avoid duplication.
      </p>
      <ul>
        <li>The <code>local</code> keyword defines a variable.</li>
        <li>Variables defined next to fields end with a comma (<code>,</code>).</li>
        <li>All other cases end with a semicolon (<code>;</code>).</li>
      </ul>
      <p>
        Try factoring out <code>"Simple Syrup"</code> to the top level or to the same level as
        the <code>pour</code> variable.
      </p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="inverse hgroup">
  <div class=hgroup-inline>
    <div class="tab-window-input" id="variables-input">
      <div class="tab-header">
      </div>
      <textarea id=variables-jsonnet>
// A regular definition.
local house_rum = 'Banks Rum';

{
  // A definition next to fields.
  local pour = 1.5,

  Daiquri: {
    ingredients: [
      { kind: house_rum, qty: pour },
      { kind: 'Lime', qty: 1 },
      { kind: 'Simple Syrup', qty: 0.5 },
    ],
    served: 'Straight Up',
  },
  Mojito: {
    ingredients: [
      {
        kind: 'Mint',
        action: 'muddle',
        qty: 6,
        unit: 'leaves',
      },
      { kind: house_rum, qty: pour },
      { kind: 'Lime', qty: 0.5 },
      { kind: 'Simple Syrup', qty: 0.5 },
      { kind: 'Soda', qty: 3 },
    ],
    garnish: 'Lime wedge',
    served: 'Over crushed ice',
  },
}

      </textarea>
    </div>
    <div class="bigarrow">➡</div>
    <div class="tab-window-output" id="variables-output">
      <div class="tab-header">
        <div class=selected onclick="tab_click(this, 'variables-json-output')">output.json</div>
      </div>
      <textarea readonly class="selected code-json" id="variables-json-output">
{
  "Daiquri": {
    "ingredients": [
      {
        "kind": "Banks Rum",
        "qty": 1.5
      },
      {
        "kind": "Lime",
        "qty": 1
      },
      {
        "kind": "Simple Syrup",
        "qty": 0.5
      }
    ],
    "served": "Straight Up"
  },
  "Mojito": {
    "garnish": "Lime wedge",
    "ingredients": [
      {
        "action": "muddle",
        "kind": "Mint",
        "qty": 6,
        "unit": "leaves"
      },
      {
        "kind": "Banks Rum",
        "qty": 1.5
      },
      {
        "kind": "Lime",
        "qty": 0.5
      },
      {
        "kind": "Simple Syrup",
        "qty": 0.5
      },
      {
        "kind": "Soda",
        "qty": 3
      }
    ],
    "served": "Over crushed ice"
  }
}

      </textarea>
    </div>
    <script>
      demo(
        'variables-input',
        {
          'variables-jsonnet': 'variables.jsonnet',
        },
        'variables.jsonnet',
        'variables-output',
        false,
        false
      );
    </script>
    <div style="clear: both"></div>
  </div>
</div>



<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <h2 id="references">References</h2>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        Another way to avoid duplication is to refer to another part of the structure.
      </p>
      <ul>
        <li><code>self</code> refers to the current object.</li>
        <li><code>$</code> refers to the outer-most object.</li>
        <li><code>['foo']</code> looks up a field.</li>
        <li><code>.f</code> can be used if the field name is an identifier.</li>
        <li><code>[10]</code> looks up an array element.</li>
        <li>Arbitrarily long paths are allowed.</li>
        <li>Array slices like <code>arr[10:20:2]</code> are allowed, like in Python.</li>
        <li>Strings can be looked up / sliced too, by unicode codepoint.</li>
      </ul>
      <p>
      Another name for a Tom Collins is a Gin Fizz.  Try adding an alias for that.
      </p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="inverse hgroup">
  <div class=hgroup-inline>
    <div class="tab-window-input" id="references-input">
      <div class="tab-header">
      </div>
      <textarea id=references-jsonnet>
{
  'Tom Collins': {
    ingredients: [
      { kind: "Farmer's Gin", qty: 1.5 },
      { kind: 'Lemon', qty: 1 },
      { kind: 'Simple Syrup', qty: 0.5 },
      { kind: 'Soda', qty: 2 },
      { kind: 'Angostura', qty: 'dash' },
    ],
    garnish: 'Maraschino Cherry',
    served: 'Tall',
  },
  Martini: {
    ingredients: [
      {
        // Use the same gin as the Tom Collins.
        kind:
          $['Tom Collins'].ingredients[0].kind,
        qty: 2,
      },
      { kind: 'Dry White Vermouth', qty: 1 },
    ],
    garnish: 'Olive',
    served: 'Straight Up',
  },
  // Create an alias.
  'Gin Martini': self.Martini,
}

      </textarea>
    </div>
    <div class="bigarrow">➡</div>
    <div class="tab-window-output" id="references-output">
      <div class="tab-header">
        <div class=selected onclick="tab_click(this, 'references-json-output')">output.json</div>
      </div>
      <textarea readonly class="selected code-json" id="references-json-output">
{
  "Gin Martini": {
    "garnish": "Olive",
    "ingredients": [
      {
        "kind": "Farmer's Gin",
        "qty": 2
      },
      {
        "kind": "Dry White Vermouth",
        "qty": 1
      }
    ],
    "served": "Straight Up"
  },
  "Martini": {
    "garnish": "Olive",
    "ingredients": [
      {
        "kind": "Farmer's Gin",
        "qty": 2
      },
      {
        "kind": "Dry White Vermouth",
        "qty": 1
      }
    ],
    "served": "Straight Up"
  },
  "Tom Collins": {
    "garnish": "Maraschino Cherry",
    "ingredients": [
      {
        "kind": "Farmer's Gin",
        "qty": 1.5
      },
      {
        "kind": "Lemon",
        "qty": 1
      },
      {
        "kind": "Simple Syrup",
        "qty": 0.5
      },
      {
        "kind": "Soda",
        "qty": 2
      },
      {
        "kind": "Angostura",
        "qty": "dash"
      }
    ],
    "served": "Tall"
  }
}

      </textarea>
    </div>
    <script>
      demo(
        'references-input',
        {
          'references-jsonnet': 'references.jsonnet',
        },
        'references.jsonnet',
        'references-output',
        false,
        false
      );
    </script>
    <div style="clear: both"></div>
  </div>
</div>



<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        In order to refer to objects between the current and outer-most object, we use a variable to
        create a name for that level:
      </p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="inverse hgroup">
  <div class=hgroup-inline>
    <div class="tab-window-input" id="inner-reference-input">
      <div class="tab-header">
      </div>
      <textarea id=inner-reference-jsonnet>
{
  Martini: {
    local drink = self,
    ingredients: [
      { kind: "Farmer's Gin", qty: 1 },
      {
        kind: 'Dry White Vermouth',
        qty: drink.ingredients[0].qty,
      },
    ],
    garnish: 'Olive',
    served: 'Straight Up',
  },
}

      </textarea>
    </div>
    <div class="bigarrow">➡</div>
    <div class="tab-window-output" id="inner-reference-output">
      <div class="tab-header">
        <div class=selected onclick="tab_click(this, 'inner-reference-json-output')">output.json</div>
      </div>
      <textarea readonly class="selected code-json" id="inner-reference-json-output">
{
  "Martini": {
    "garnish": "Olive",
    "ingredients": [
      {
        "kind": "Farmer's Gin",
        "qty": 1
      },
      {
        "kind": "Dry White Vermouth",
        "qty": 1
      }
    ],
    "served": "Straight Up"
  }
}

      </textarea>
    </div>
    <script>
      demo(
        'inner-reference-input',
        {
          'inner-reference-jsonnet': 'inner-reference.jsonnet',
        },
        'inner-reference.jsonnet',
        'inner-reference-output',
        false,
        false
      );
    </script>
    <div style="clear: both"></div>
  </div>
</div>



<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <h2 id="arithmetic">Arithmetic</h2>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        Arithmetic includes numeric operations like multiplication but also various operations on
        other types.
      </p>
      <ul>
        <li>Use floating point arithmetic, bitwise ops, boolean logic.</li>
        <li>
          Strings may be concatenated with <code>+</code>, which implicitly converts
          one operand to string if needed.
        </li>
        <li>Two strings can be compared with <code>&lt;</code> (unicode codepoint order).</li>
        <li>
          Objects may be combined with <code>+</code> where the right-hand side wins field
          conflicts.
        </li>
        <li>Test if a field is in an object with <code>in</code>.</li>
        <li><code>==</code> is deep value equality.</li>
        <li>Python-compatible string formatting is available via <code>%</code>.  When combined with
        <code>|||</code> this can be used for templating text files.</li>
      </ul>
      <p>Try dividing by zero to see what happens.</p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="inverse hgroup">
  <div class=hgroup-inline>
    <div class="tab-window-input" id="arith-input">
      <div class="tab-header">
      </div>
      <textarea id=arith-jsonnet>
{
  concat_array: [1, 2, 3] + [4],
  concat_string: '123' + 4,
  equality1: 1 == '1',
  equality2: [{}, { x: 3 - 1 }]
             == [{}, { x: 2 }],
  ex1: 1 + 2 * 3 / (4 + 5),
  // Bitwise operations first cast to int.
  ex2: self.ex1 | 3,
  // Modulo operator.
  ex3: self.ex1 % 2,
  // Boolean logic
  ex4: (4 > 3) && (1 <= 3) || false,
  // Mixing objects together
  obj: { a: 1, b: 2 } + { b: 3, c: 4 },
  // Test if a field is in an object
  obj_member: 'foo' in { foo: 1 },
  // String formatting
  str1: 'The value of self.ex2 is '
        + self.ex2 + '.',
  str2: 'The value of self.ex2 is %g.'
        % self.ex2,
  str3: 'ex1=%0.2f, ex2=%0.2f'
        % [self.ex1, self.ex2],
  // By passing self, we allow ex1 and ex2 to
  // be extracted internally.
  str4: 'ex1=%(ex1)0.2f, ex2=%(ex2)0.2f'
        % self,
  // Do textual templating of entire files:
  str5: |||
    ex1=%(ex1)0.2f
    ex2=%(ex2)0.2f
  ||| % self,
}

      </textarea>
    </div>
    <div class="bigarrow">➡</div>
    <div class="tab-window-output" id="arith-output">
      <div class="tab-header">
        <div class=selected onclick="tab_click(this, 'arith-json-output')">output.json</div>
      </div>
      <textarea readonly class="selected code-json" id="arith-json-output">
{
  "concat_array": [
    1,
    2,
    3,
    4
  ],
  "concat_string": "1234",
  "equality1": false,
  "equality2": true,
  "ex1": 1.6666666666666665,
  "ex2": 3,
  "ex3": 1.6666666666666665,
  "ex4": true,
  "obj": {
    "a": 1,
    "b": 3,
    "c": 4
  },
  "obj_member": true,
  "str1": "The value of self.ex2 is 3.",
  "str2": "The value of self.ex2 is 3.",
  "str3": "ex1=1.67, ex2=3.00",
  "str4": "ex1=1.67, ex2=3.00",
  "str5": "ex1=1.67\nex2=3.00\n"
}

      </textarea>
    </div>
    <script>
      demo(
        'arith-input',
        {
          'arith-jsonnet': 'arith.jsonnet',
        },
        'arith.jsonnet',
        'arith-output',
        false,
        false
      );
    </script>
    <div style="clear: both"></div>
  </div>
</div>



<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <h2 id="functions">Functions</h2>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        Like Python, functions have positional parameters, named parameters, and default arguments.
        Closures are also supported.  The examples below should demonstrate the syntax.  Many
        functions are already defined in the <a href=/ref/std.html>standard library</a>.
      </p>
      <p>
        Try writing a function <code>is_even</code> that uses the modulo operator <code>%</code> and
        returns either true or false.
      </p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="inverse hgroup">
  <div class=hgroup-inline>
    <div class="tab-window-input" id="functions-input">
      <div class="tab-header">
      </div>
      <textarea id=functions-jsonnet>
// Define a local function.
// Default arguments are like Python:
local my_function(x, y=10) = x + y;

local object = {
  // A method
  my_method(x): x * x,
};

{
  // Functions are first class citizens.
  call_inline_function:
    (function(x) x * x)(5),

  // Using the variable fetches the function,
  // the parens call the function.
  call: my_function(2),

  // Like python, parameters can be named at
  // call time.
  named_params: my_function(x=2),
  // This allows changing their order
  named_params2: my_function(y=3, x=2),

  // object.my_method returns the function,
  // which is then called like any other.
  call_method1: object.my_method(3),

  standard_lib:
    std.join(' ', std.split('foo/bar', '/')),
  len: [
    std.length('hello'),
    std.length([1, 2, 3]),
  ],
}

      </textarea>
    </div>
    <div class="bigarrow">➡</div>
    <div class="tab-window-output" id="functions-output">
      <div class="tab-header">
        <div class=selected onclick="tab_click(this, 'functions-json-output')">output.json</div>
      </div>
      <textarea readonly class="selected code-json" id="functions-json-output">
{
  "call": 12,
  "call_inline_function": 25,
  "call_method1": 9,
  "len": [
    5,
    3
  ],
  "named_params": 12,
  "named_params2": 5,
  "standard_lib": "foo bar"
}

      </textarea>
    </div>
    <script>
      demo(
        'functions-input',
        {
          'functions-jsonnet': 'functions.jsonnet',
        },
        'functions.jsonnet',
        'functions-output',
        false,
        false
      );
    </script>
    <div style="clear: both"></div>
  </div>
</div>



<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        And here's an example with cocktails.
      </p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="inverse hgroup">
  <div class=hgroup-inline>
    <div class="tab-window-input" id="sours-input">
      <div class="tab-header">
      </div>
      <textarea id=sours-jsonnet>
// This function returns an object. Although
// the braces look like Java or C++ they do
// not mean a statement block, they are instead
// the value being returned.
local Sour(spirit, garnish='Lemon twist') = {
  ingredients: [
    { kind: spirit, qty: 2 },
    { kind: 'Egg white', qty: 1 },
    { kind: 'Lemon Juice', qty: 1 },
    { kind: 'Simple Syrup', qty: 1 },
  ],
  garnish: garnish,
  served: 'Straight Up',
};

{
  'Whiskey Sour': Sour('Bulleit Bourbon',
                       'Orange bitters'),
  'Pisco Sour': Sour('Machu Pisco',
                     'Angostura bitters'),
}

      </textarea>
    </div>
    <div class="bigarrow">➡</div>
    <div class="tab-window-output" id="sours-output">
      <div class="tab-header">
        <div class=selected onclick="tab_click(this, 'sours-json-output')">output.json</div>
      </div>
      <textarea readonly class="selected code-json" id="sours-json-output">
{
  "Pisco Sour": {
    "garnish": "Angostura bitters",
    "ingredients": [
      {
        "kind": "Machu Pisco",
        "qty": 2
      },
      {
        "kind": "Egg white",
        "qty": 1
      },
      {
        "kind": "Lemon Juice",
        "qty": 1
      },
      {
        "kind": "Simple Syrup",
        "qty": 1
      }
    ],
    "served": "Straight Up"
  },
  "Whiskey Sour": {
    "garnish": "Orange bitters",
    "ingredients": [
      {
        "kind": "Bulleit Bourbon",
        "qty": 2
      },
      {
        "kind": "Egg white",
        "qty": 1
      },
      {
        "kind": "Lemon Juice",
        "qty": 1
      },
      {
        "kind": "Simple Syrup",
        "qty": 1
      }
    ],
    "served": "Straight Up"
  }
}

      </textarea>
    </div>
    <script>
      demo(
        'sours-input',
        {
          'sours-jsonnet': 'sours.jsonnet',
        },
        'sours.jsonnet',
        'sours-output',
        false,
        false
      );
    </script>
    <div style="clear: both"></div>
  </div>
</div>



<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <h2 id="conditionals">Conditionals</h2>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        Conditional expressions look like <code>if b then e else e</code>. The
        <code>else</code> branch is optional and defaults to <code>null</code>.
      </p>
      <p>
        Try adding the missing Large Virgin Mojito:
      </p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="inverse hgroup">
  <div class=hgroup-inline>
    <div class="tab-window-input" id="conditionals-input">
      <div class="tab-header">
      </div>
      <textarea id=conditionals-jsonnet>
local Mojito(virgin=false, large=false) = {
  // A local next to fields ends with ','.
  local factor = if large then 2 else 1,
  // The ingredients are split into 3 arrays,
  // the middle one is either length 1 or 0.
  ingredients: [
    {
      kind: 'Mint',
      action: 'muddle',
      qty: 6 * factor,
      unit: 'leaves',
    },
  ] + if virgin then [] else [
    { kind: 'Banks', qty: 1.5 * factor },
  ] + [
    { kind: 'Lime', qty: 0.5 * factor },
    { kind: 'Simple Syrup', qty: 0.5 * factor },
    { kind: 'Soda', qty: 3 * factor },
  ],
  // Returns null if not large.
  garnish: if large then 'Lime wedge',
  served: 'Over crushed ice',
};

{
  Mojito: Mojito(),
  'Virgin Mojito': Mojito(virgin=true),
  'Large Mojito': Mojito(large=true),
}

      </textarea>
    </div>
    <div class="bigarrow">➡</div>
    <div class="tab-window-output" id="conditionals-output">
      <div class="tab-header">
        <div class=selected onclick="tab_click(this, 'conditionals-json-output')">output.json</div>
      </div>
      <textarea readonly class="selected code-json" id="conditionals-json-output">
{
  "Large Mojito": {
    "garnish": "Lime wedge",
    "ingredients": [
      {
        "action": "muddle",
        "kind": "Mint",
        "qty": 12,
        "unit": "leaves"
      },
      {
        "kind": "Banks",
        "qty": 3
      },
      {
        "kind": "Lime",
        "qty": 1
      },
      {
        "kind": "Simple Syrup",
        "qty": 1
      },
      {
        "kind": "Soda",
        "qty": 6
      }
    ],
    "served": "Over crushed ice"
  },
  "Mojito": {
    "garnish": null,
    "ingredients": [
      {
        "action": "muddle",
        "kind": "Mint",
        "qty": 6,
        "unit": "leaves"
      },
      {
        "kind": "Banks",
        "qty": 1.5
      },
      {
        "kind": "Lime",
        "qty": 0.5
      },
      {
        "kind": "Simple Syrup",
        "qty": 0.5
      },
      {
        "kind": "Soda",
        "qty": 3
      }
    ],
    "served": "Over crushed ice"
  },
  "Virgin Mojito": {
    "garnish": null,
    "ingredients": [
      {
        "action": "muddle",
        "kind": "Mint",
        "qty": 6,
        "unit": "leaves"
      }
    ],
    "served": "Over crushed ice"
  }
}

      </textarea>
    </div>
    <script>
      demo(
        'conditionals-input',
        {
          'conditionals-jsonnet': 'conditionals.jsonnet',
        },
        'conditionals.jsonnet',
        'conditionals-output',
        false,
        false
      );
    </script>
    <div style="clear: both"></div>
  </div>
</div>



<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <h2 id="computed_field_names">Computed Field Names</h2>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        Jsonnet objects can be used like a <code>std::map</code> or similar datastructures from
        regular languages.
      </p>
      <ul>
        <li>Recall that a field lookup can be computed with <code>obj[e]</code></li>
        <li>The definition equivalent is <code>{[e]: </code>... <code>}</code></li>
        <li>
          <code>self</code> or object locals cannot be accessed when field names are being computed,
          since the object is not yet constructed.
        </li>
        <li>
          If a field name evaluates to <code>null</code> during object construction, the field is
          omitted.  This works nicely with the default false branch of a conditional (see below).
        </li>
      </ul>
      <p>
        Try adding <code>[self.f]: 'f'</code> to see what happens, while pondering what that
        could even mean!
      </p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="inverse hgroup">
  <div class=hgroup-inline>
    <div class="tab-window-input" id="computed-fields-input">
      <div class="tab-header">
      </div>
      <textarea id=computed-fields-jsonnet>
local Margarita(salted) = {
  ingredients: [
    { kind: 'Tequila Blanco', qty: 2 },
    { kind: 'Lime', qty: 1 },
    { kind: 'Cointreau', qty: 1 },
  ],
  [if salted then 'garnish']: 'Salt',
};
{
  Margarita: Margarita(true),
  'Margarita Unsalted': Margarita(false),
}

      </textarea>
    </div>
    <div class="bigarrow">➡</div>
    <div class="tab-window-output" id="computed-fields-output">
      <div class="tab-header">
        <div class=selected onclick="tab_click(this, 'computed-fields-json-output')">output.json</div>
      </div>
      <textarea readonly class="selected code-json" id="computed-fields-json-output">
{
  "Margarita": {
    "garnish": "Salt",
    "ingredients": [
      {
        "kind": "Tequila Blanco",
        "qty": 2
      },
      {
        "kind": "Lime",
        "qty": 1
      },
      {
        "kind": "Cointreau",
        "qty": 1
      }
    ]
  },
  "Margarita Unsalted": {
    "ingredients": [
      {
        "kind": "Tequila Blanco",
        "qty": 2
      },
      {
        "kind": "Lime",
        "qty": 1
      },
      {
        "kind": "Cointreau",
        "qty": 1
      }
    ]
  }
}

      </textarea>
    </div>
    <script>
      demo(
        'computed-fields-input',
        {
          'computed-fields-jsonnet': 'computed-fields.jsonnet',
        },
        'computed-fields.jsonnet',
        'computed-fields-output',
        false,
        false
      );
    </script>
    <div style="clear: both"></div>
  </div>
</div>



<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <h2 id="comprehension">Array and Object Comprehension</h2>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        What if you want to make an array or object and you don't know how many elements / fields
        they will have at run-time?  Jsonnet has Python-style array and object comprehension
        constructs to allow this.
      </p>
      <ul>
        <li>Any nesting of <code>for</code> and <code>if</code> can be used.</li>
        <li>The nest behaves like a loop nest, although the body is written first.</li>
      </ul>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="inverse hgroup">
  <div class=hgroup-inline>
    <div class="tab-window-input" id="comprehensions-input">
      <div class="tab-header">
      </div>
      <textarea id=comprehensions-jsonnet>
local arr = std.range(5, 8);
{
  array_comprehensions: {
    higher: [x + 3 for x in arr],
    lower: [x - 3 for x in arr],
    evens: [x for x in arr if x % 2 == 0],
    odds: [x for x in arr if x % 2 == 1],
    evens_and_odds: [
      '%d-%d' % [x, y]
      for x in arr
      if x % 2 == 0
      for y in arr
      if y % 2 == 1
    ],
  },
  object_comprehensions: {
    evens: {
      ['f' + x]: true
      for x in arr
      if x % 2 == 0
    },
    // Use object composition (+) to add in
    // static fields:
    mixture: {
      f: 1,
      g: 2,
    } + {
      [x]: 0
      for x in ['a', 'b', 'c']
    },
  },
}

      </textarea>
    </div>
    <div class="bigarrow">➡</div>
    <div class="tab-window-output" id="comprehensions-output">
      <div class="tab-header">
        <div class=selected onclick="tab_click(this, 'comprehensions-json-output')">output.json</div>
      </div>
      <textarea readonly class="selected code-json" id="comprehensions-json-output">
{
  "array_comprehensions": {
    "evens": [
      6,
      8
    ],
    "evens_and_odds": [
      "6-5",
      "6-7",
      "8-5",
      "8-7"
    ],
    "higher": [
      8,
      9,
      10,
      11
    ],
    "lower": [
      2,
      3,
      4,
      5
    ],
    "odds": [
      5,
      7
    ]
  },
  "object_comprehensions": {
    "evens": {
      "f6": true,
      "f8": true
    },
    "mixture": {
      "a": 0,
      "b": 0,
      "c": 0,
      "f": 1,
      "g": 2
    }
  }
}

      </textarea>
    </div>
    <script>
      demo(
        'comprehensions-input',
        {
          'comprehensions-jsonnet': 'comprehensions.jsonnet',
        },
        'comprehensions.jsonnet',
        'comprehensions-output',
        false,
        false
      );
    </script>
    <div style="clear: both"></div>
  </div>
</div>



<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        Below, a less contrived example.  The first cocktail has equal parts of three ingredients.
        The second iterates over an array of records - name prefix and fruit juice.
      </p>
      <p>
        Try adding a "Red Screwdriver" with cranberry juice.
      </p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="inverse hgroup">
  <div class=hgroup-inline>
    <div class="tab-window-input" id="cocktail-comprehensions-input">
      <div class="tab-header">
      </div>
      <textarea id=cocktail-comprehensions-jsonnet>
{
  cocktails: {
    "Bee's Knees": {
      // Construct the ingredients by using
      // 4/3 oz of each element in the given
      // list.
      ingredients: [  // Array comprehension.
        { kind: kind, qty: 4 / 3 }
        for kind in [
          'Honey Syrup',
          'Lemon Juice',
          'Farmers Gin',
        ]
      ],
      garnish: 'Lemon Twist',
      served: 'Straight Up',
    },
  } + {  // Object comprehension.
    [sd.name + 'Screwdriver']: {
      ingredients: [
        { kind: 'Vodka', qty: 1.5 },
        { kind: sd.fruit, qty: 3 },
      ],
      served: 'On The Rocks',
    }
    for sd in [
      { name: 'Yellow ', fruit: 'Lemonade' },
      { name: '', fruit: 'Orange Juice' },
    ]
  },
}

      </textarea>
    </div>
    <div class="bigarrow">➡</div>
    <div class="tab-window-output" id="cocktail-comprehensions-output">
      <div class="tab-header">
        <div class=selected onclick="tab_click(this, 'cocktail-comprehensions-json-output')">output.json</div>
      </div>
      <textarea readonly class="selected code-json" id="cocktail-comprehensions-json-output">
{
  "cocktails": {
    "Bee's Knees": {
      "garnish": "Lemon Twist",
      "ingredients": [
        {
          "kind": "Honey Syrup",
          "qty": 1.3333333333333333
        },
        {
          "kind": "Lemon Juice",
          "qty": 1.3333333333333333
        },
        {
          "kind": "Farmers Gin",
          "qty": 1.3333333333333333
        }
      ],
      "served": "Straight Up"
    },
    "Screwdriver": {
      "ingredients": [
        {
          "kind": "Vodka",
          "qty": 1.5
        },
        {
          "kind": "Orange Juice",
          "qty": 3
        }
      ],
      "served": "On The Rocks"
    },
    "Yellow Screwdriver": {
      "ingredients": [
        {
          "kind": "Vodka",
          "qty": 1.5
        },
        {
          "kind": "Lemonade",
          "qty": 3
        }
      ],
      "served": "On The Rocks"
    }
  }
}

      </textarea>
    </div>
    <script>
      demo(
        'cocktail-comprehensions-input',
        {
          'cocktail-comprehensions-jsonnet': 'cocktail-comprehensions.jsonnet',
        },
        'cocktail-comprehensions.jsonnet',
        'cocktail-comprehensions-output',
        false,
        false
      );
    </script>
    <div style="clear: both"></div>
  </div>
</div>



<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <h2 id="imports">Imports</h2>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        It's possible to import both code and raw data from other files.
      </p>
      <ul>
        <li>The <code>import</code> construct is like copy/pasting Jsonnet code.</li>
        <li>Files designed for import by convention end with <tt>.libsonnet</tt></li>
        <li>Raw JSON can be imported this way too.</li>
        <li>The <code>importstr</code> construct is for verbatim UTF-8 text.</li>
      </ul>
      <p>
        Usually, imported Jsonnet content is stashed in a top-level local variable.  This
        resembles the way other programming languages handle modules.  Jsonnet libraries typically
        return an object, so that they can easily be extended.  Neither of these conventions are
        enforced.
      </p>
      <p>
        Try including the Cosmopolitan from the library.
      </p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="inverse hgroup">
  <div class=hgroup-inline>
    <div class="tab-window-input" id="imports-input">
      <div class="tab-header">
      </div>
      <textarea id=imports-jsonnet>
local martinis = import 'martinis.libsonnet';

{
  'Vodka Martini': martinis['Vodka Martini'],
  Manhattan: {
    ingredients: [
      { kind: 'Rye', qty: 2.5 },
      { kind: 'Sweet Red Vermouth', qty: 1 },
      { kind: 'Angostura', qty: 'dash' },
    ],
    garnish: importstr 'garnish.txt',
    served: 'Straight Up',
  },
}

      </textarea>
      <textarea id=martinis-libsonnet>
{
  'Vodka Martini': {
    ingredients: [
      { kind: 'Vodka', qty: 2 },
      { kind: 'Dry White Vermouth', qty: 1 },
    ],
    garnish: 'Olive',
    served: 'Straight Up',
  },
  Cosmopolitan: {
    ingredients: [
      { kind: 'Vodka', qty: 2 },
      { kind: 'Triple Sec', qty: 0.5 },
      { kind: 'Cranberry Juice', qty: 0.75 },
      { kind: 'Lime Juice', qty: 0.5 },
    ],
    garnish: 'Orange Peel',
    served: 'Straight Up',
  },
}

      </textarea>
      <textarea id=garnish-txt>
Maraschino Cherry
      </textarea>
    </div>
    <div class="bigarrow">➡</div>
    <div class="tab-window-output" id="imports-output">
      <div class="tab-header">
        <div class=selected onclick="tab_output_click(this, 'imports-json-output')">output.json</div>
      </div>
      <textarea readonly class="selected code-json" id="imports-json-output">
{
  "Manhattan": {
    "garnish": "Maraschino Cherry",
    "ingredients": [
      {
        "kind": "Rye",
        "qty": 2.5
      },
      {
        "kind": "Sweet Red Vermouth",
        "qty": 1
      },
      {
        "kind": "Angostura",
        "qty": "dash"
      }
    ],
    "served": "Straight Up"
  },
  "Vodka Martini": {
    "garnish": "Olive",
    "ingredients": [
      {
        "kind": "Vodka",
        "qty": 2
      },
      {
        "kind": "Dry White Vermouth",
        "qty": 1
      }
    ],
    "served": "Straight Up"
  }
}

      </textarea>
    </div>
    <script>
      demo(
        'imports-input',
        {
          'imports-jsonnet': 'imports.jsonnet',
          'martinis-libsonnet': 'martinis.libsonnet',
          'garnish-txt': 'garnish.txt',
        },
        'imports.jsonnet',
        'imports-output',
        false,
        false
      );
    </script>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        The following example shows how to write libraries of functions.  It also shows how to
        define a local variable in the scope of a function.  Try adding the Bee's Knees from above
        using the utility library.
      </p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="inverse hgroup">
  <div class=hgroup-inline>
    <div class="tab-window-input" id="negroni-input">
      <div class="tab-header">
      </div>
      <textarea id=negroni-jsonnet>
local utils = import 'utils.libsonnet';
{
  Negroni: {
    // Divide 3oz among the 3 ingredients.
    ingredients: utils.equal_parts(3, [
      'Farmers Gin',
      'Sweet Red Vermouth',
      'Campari',
    ]),
    garnish: 'Orange Peel',
    served: 'On The Rocks',
  },
}

      </textarea>
      <textarea id=utils-libsonnet>
{
  equal_parts(size, ingredients)::
    // Define a function-scoped variable.
    local qty = size / std.length(ingredients);
    // Return an array.
    [
      { kind: i, qty: qty }
      for i in ingredients
    ],
}

      </textarea>
    </div>
    <div class="bigarrow">➡</div>
    <div class="tab-window-output" id="negroni-output">
      <div class="tab-header">
        <div class=selected onclick="tab_output_click(this, 'negroni-json-output')">output.json</div>
      </div>
      <textarea readonly class="selected code-json" id="negroni-json-output">
{
  "Negroni": {
    "garnish": "Orange Peel",
    "ingredients": [
      {
        "kind": "Farmers Gin",
        "qty": 1
      },
      {
        "kind": "Sweet Red Vermouth",
        "qty": 1
      },
      {
        "kind": "Campari",
        "qty": 1
      }
    ],
    "served": "On The Rocks"
  }
}

      </textarea>
    </div>
    <script>
      demo(
        'negroni-input',
        {
          'negroni-jsonnet': 'negroni.jsonnet',
          'utils-libsonnet': 'utils.libsonnet',
        },
        'negroni.jsonnet',
        'negroni-output',
        false,
        false
      );
    </script>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <h2 id="errors">Errors</h2>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        Errors can arise from the language itself (e.g. an array overrun) or thrown from Jsonnet
        code.  Stack traces provide context for the error.
      </p>
      <ul>
        <li>To raise an error: <code>error "foo"</code></li>
        <li>To assert a condition before an expression: <code>assert "foo";</code></li>
        <li>A custom failure message: <code>assert "foo" : "message";</code></li>
        <li>Assert fields have a property: <code>assert self.f == 10,</code></li>
        <li>With custom failure message: <code>assert "foo" : "message",</code></li>
      </ul>
      <p>
        Try modifying the code below to trigger the assertion failures, and observe the error
        messages and stack traces that result.
      </p>
      <p>
        You might wonder why the divide-by-zero is not triggered in the equal_parts function, since
        that code occurs before the <code>std.length()</code> check.  Jsonnet is a lazy
        language, so variable initializers are not evaluated until the variable is used.  Evaluation
        order is very hard to notice.  It only becomes relevant when code throws errors, or takes a
        long time to execute.  For more discussion of laziness, see <a
        href=/articles/design.html>design rationale</a>.
      </p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="inverse hgroup">
  <div class=hgroup-inline>
    <div class="tab-window-input" id="error-examples-input">
      <div class="tab-header">
      </div>
      <textarea id=error-examples-jsonnet>
// Extend above example to sanity check input.
local equal_parts(size, ingredients) =
  local qty = size / std.length(ingredients);
  // Check a pre-condition
  if std.length(ingredients) == 0 then
    error 'Empty ingredients.'
  else [
    { kind: i, qty: qty }
    for i in ingredients
  ];

local subtract(a, b) =
  assert a > b : 'a must be bigger than b';
  a - b;

assert std.isFunction(subtract);

{
  test1: equal_parts(1, ['Whiskey']),
  test2: subtract(10, 3),
  object: {
    assert self.f < self.g : 'wat',
    f: 1,
    g: 2,
  },
  assert std.isObject(self.object),
}

      </textarea>
    </div>
    <div class="bigarrow">➡</div>
    <div class="tab-window-output" id="error-examples-output">
      <div class="tab-header">
        <div class=selected onclick="tab_click(this, 'error-examples-json-output')">output.json</div>
      </div>
      <textarea readonly class="selected code-json" id="error-examples-json-output">
{
  "object": {
    "f": 1,
    "g": 2
  },
  "test1": [
    {
      "kind": "Whiskey",
      "qty": 1
    }
  ],
  "test2": 7
}

      </textarea>
    </div>
    <script>
      demo(
        'error-examples-input',
        {
          'error-examples-jsonnet': 'error-examples.jsonnet',
        },
        'error-examples.jsonnet',
        'error-examples-output',
        false,
        false
      );
    </script>
    <div style="clear: both"></div>
  </div>
</div>



<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <h2 id="parameterize-entire-config">Parameterize Entire Config</h2>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        Jsonnet is hermetic: It always generates the same data no matter the execution environment.
        This is an important property but there are times when you want a few carefully chosen
        parameters at the top level.  There are two ways to do this, with different properties.
      </p>
      <ul>
        <li>
          <b>External variables</b>, which are accessible anywhere in the config, or any file,
          using <code>std.extVar("foo")</code>.
        </li>
        <li>
          <b>Top-level arguments</b>, where the whole config is expressed as a function.
        </li>
      </ul>
      <p>
        To illustrate the differences, We'll show how the same example is expressed in each case.
      </p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <h3 id="parameterize-entire-config">External variables</h3>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        The following example binds two external variables, listed below.  Any Jsonnet value can be
        bound to an external variable, even functions.
      </p>
      <ul>
        <li><code>prefix</code> is bound to the string <code>"Happy Hour "</code></li>
        <li><code>brunch</code> is bound to <code>true</code></li>
      </ul>
      <p>
        The values are configured when the Jsonnet virtual machine is initialized, by passing either
        1) Jsonnet code (which evaluates to the value), 2) or a raw string.  The latter is just a
        convenience, because escaping a string to pass it as Jsonnet code can be tedious.  To make
        this concrete, the above variables can be configured with the following commandline:
      </p>
      <pre>jsonnet --ext-str prefix="Happy Hour " \
        --ext-code brunch=true ...
      </pre>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="inverse hgroup">
  <div class=hgroup-inline>
    <div class="tab-window-input" id="top-level-ext-input">
      <div class="tab-header">
      </div>
      <textarea id=top-level-ext-jsonnet>
local lib = import 'library-ext.libsonnet';
{
  [std.extVar('prefix') + 'Pina Colada']: {
    ingredients: [
      { kind: 'Rum', qty: 3 },
      { kind: 'Pineapple Juice', qty: 6 },
      { kind: 'Coconut Cream', qty: 2 },
      { kind: 'Ice', qty: 12 },
    ],
    garnish: 'Pineapple slice',
    served: 'Frozen',
  },

  [if std.extVar('brunch') then
    std.extVar('prefix') + 'Bloody Mary'
  ]: {
    ingredients: [
      { kind: 'Vodka', qty: 1.5 },
      { kind: 'Tomato Juice', qty: 3 },
      { kind: 'Lemon Juice', qty: 1.5 },
      { kind: 'Worcestershire', qty: 0.25 },
      { kind: 'Tobasco Sauce', qty: 0.15 },
    ],
    garnish: 'Celery salt & pepper',
    served: 'Tall',
  },

  [std.extVar('prefix') + 'Mimosa']:
    lib.Mimosa,
}

      </textarea>
      <textarea id=library-ext-libsonnet>
local fizz = if std.extVar('brunch') then
  'Cheap Sparkling Wine'
else
  'Champagne';
{
  Mimosa: {
    ingredients: [
      { kind: fizz, qty: 3 },
      { kind: 'Orange Juice', qty: 3 },
    ],
    garnish: 'Orange Slice',
    served: 'Champagne Flute',
  },
}

      </textarea>
    </div>
    <div class="bigarrow">➡</div>
    <div class="tab-window-output" id="top-level-ext-output">
      <div class="tab-header">
        <div class=selected onclick="tab_click(this, 'top-level-ext-json-output')">output.json</div>
      </div>
      <textarea readonly class="selected code-json" id="top-level-ext-json-output">
{
  "Happy Hour Bloody Mary": {
    "garnish": "Celery salt & pepper",
    "ingredients": [
      {
        "kind": "Vodka",
        "qty": 1.5
      },
      {
        "kind": "Tomato Juice",
        "qty": 3
      },
      {
        "kind": "Lemon Juice",
        "qty": 1.5
      },
      {
        "kind": "Worcestershire",
        "qty": 0.25
      },
      {
        "kind": "Tobasco Sauce",
        "qty": 0.15
      }
    ],
    "served": "Tall"
  },
  "Happy Hour Mimosa": {
    "garnish": "Orange Slice",
    "ingredients": [
      {
        "kind": "Cheap Sparkling Wine",
        "qty": 3
      },
      {
        "kind": "Orange Juice",
        "qty": 3
      }
    ],
    "served": "Champagne Flute"
  },
  "Happy Hour Pina Colada": {
    "garnish": "Pineapple slice",
    "ingredients": [
      {
        "kind": "Rum",
        "qty": 3
      },
      {
        "kind": "Pineapple Juice",
        "qty": 6
      },
      {
        "kind": "Coconut Cream",
        "qty": 2
      },
      {
        "kind": "Ice",
        "qty": 12
      }
    ],
    "served": "Frozen"
  }
}

      </textarea>
    </div>
    <script>
      demo(
        'top-level-ext-input',
        {
          'top-level-ext-jsonnet': 'top-level-ext.jsonnet',
          'library-ext-libsonnet': 'library-ext.libsonnet',
        },
        'top-level-ext.jsonnet',
        'top-level-ext-output',
        false,
        false,
        {
          ext_str: {
            prefix: 'Happy Hour ',
          },
          ext_code: {
            brunch: 'true',
          },
        }
      );
    </script>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <h3 id="parameterize-entire-config">Top-level arguments</h3>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        Alternatively the same code can be written using top-level arguments, where the whole config
        is written as a function.  How does this differ to using external variables?
      </p>
      <ul>
        <li>Values must be explicitly threaded through files</li>
        <li>Default values can be provided</li>
        <li>The config can be imported as a library and called as a function</li>
      </ul>
      <p>
        Generally, top-level arguments are the safer and easier way to parameterize an entire
        config, because the variables are not global and it's clear what parts of the config
        are dependent on their environment.  However, they do require more explicit threading of
        the values into other imported code.  Here's the equivalent invocation of the Jsonnet
        command-line tool:
      </p>
      <pre>jsonnet --tla-str prefix="Happy Hour " \
        --tla-code brunch=true ...
      </pre>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="inverse hgroup">
  <div class=hgroup-inline>
    <div class="tab-window-input" id="top-level-tla-input">
      <div class="tab-header">
      </div>
      <textarea id=top-level-tla-jsonnet>
local lib = import 'library-tla.libsonnet';

// Here is the top-level function, note brunch
// now has a default value.
function(prefix, brunch=false) {

  [prefix + 'Pina Colada']: {
    ingredients: [
      { kind: 'Rum', qty: 3 },
      { kind: 'Pineapple Juice', qty: 6 },
      { kind: 'Coconut Cream', qty: 2 },
      { kind: 'Ice', qty: 12 },
    ],
    garnish: 'Pineapple slice',
    served: 'Frozen',
  },

  [if brunch then prefix + 'Bloody Mary']: {
    ingredients: [
      { kind: 'Vodka', qty: 1.5 },
      { kind: 'Tomato Juice', qty: 3 },
      { kind: 'Lemon Juice', qty: 1.5 },
      { kind: 'Worcestershire', qty: 0.25 },
      { kind: 'Tobasco Sauce', qty: 0.15 },
    ],
    garnish: 'Celery salt & pepper',
    served: 'Tall',
  },

  [prefix + 'Mimosa']: lib.Mimosa(brunch),
}

      </textarea>
      <textarea id=library-tla-libsonnet>
{
  // Note that the Mimosa is now
  // parameterized.
  Mimosa(brunch): {
    local fizz = if brunch then
      'Cheap Sparkling Wine'
    else
      'Champagne',
    ingredients: [
      { kind: fizz, qty: 3 },
      { kind: 'Orange Juice', qty: 3 },
    ],
    garnish: 'Orange Slice',
    served: 'Champagne Flute',
  },
}


      </textarea>
    </div>
    <div class="bigarrow">➡</div>
    <div class="tab-window-output" id="top-level-tla-output">
      <div class="tab-header">
        <div class=selected onclick="tab_click(this, 'top-level-tla-json-output')">output.json</div>
      </div>
      <textarea readonly class="selected code-json" id="top-level-tla-json-output">
{
  "Happy Hour Bloody Mary": {
    "garnish": "Celery salt & pepper",
    "ingredients": [
      {
        "kind": "Vodka",
        "qty": 1.5
      },
      {
        "kind": "Tomato Juice",
        "qty": 3
      },
      {
        "kind": "Lemon Juice",
        "qty": 1.5
      },
      {
        "kind": "Worcestershire",
        "qty": 0.25
      },
      {
        "kind": "Tobasco Sauce",
        "qty": 0.15
      }
    ],
    "served": "Tall"
  },
  "Happy Hour Mimosa": {
    "garnish": "Orange Slice",
    "ingredients": [
      {
        "kind": "Cheap Sparkling Wine",
        "qty": 3
      },
      {
        "kind": "Orange Juice",
        "qty": 3
      }
    ],
    "served": "Champagne Flute"
  },
  "Happy Hour Pina Colada": {
    "garnish": "Pineapple slice",
    "ingredients": [
      {
        "kind": "Rum",
        "qty": 3
      },
      {
        "kind": "Pineapple Juice",
        "qty": 6
      },
      {
        "kind": "Coconut Cream",
        "qty": 2
      },
      {
        "kind": "Ice",
        "qty": 12
      }
    ],
    "served": "Frozen"
  }
}

      </textarea>
    </div>
    <script>
      demo(
        'top-level-tla-input',
        {
          'top-level-tla-jsonnet': 'top-level-tla.jsonnet',
          'library-tla-libsonnet': 'library-tla.libsonnet',
        },
        'top-level-tla.jsonnet',
        'top-level-tla-output',
        false,
        false,
        {
          tla_str: {
            prefix: 'Happy Hour ',
          },
          tla_code: {
            brunch: 'true',
          },
        }
      );
    </script>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <h2 id="oo">Object-Orientation</h2>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        In general, object-orientation makes it easy to define many variants from a single "base".
        Unlike Java, C++ and Python, where classes extend other classes, in Jsonnet, objects extend
        other objects.  We have already discussed some of the raw ingredients for this, albeit in
        isolation:
      </p>
      <ul>
        <li>Objects (which we inherit from JSON)</li>
        <li>The <dfn>object composition</dfn> operator <code>+</code>, which merges two objects,
        choosing the right hand side when fields collide</li>
        <li>The <code>self</code> keyword, a reference to the current object</li>
      </ul>
      <p>
        When these features are combined together and with the following <i>new</i> features, things
        get a lot more interesting:
      </p>
      <ul>
        <li>Hidden fields, defined with <code>::</code>, which do not appear in generated JSON</li>
        <li>The <code>super</code> keyword, which has its usual meaning</li>
        <li>The <code>+:</code> field syntax for overriding deeply nested fields</li>
      </ul>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        The following example is contrived but demonstrates a few of the features using the
        classical language of object-orientation, "derived" and "base".
      </p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="inverse hgroup">
  <div class=hgroup-inline>
    <div class="tab-window-input" id="oo-contrived-input">
      <div class="tab-header">
      </div>
      <textarea id=oo-contrived-jsonnet>
local Base = {
  f: 2,
  g: self.f + 100,
};

local WrapperBase = {
  Base: Base,
};

{
  Derived: Base + {
    f: 5,
    old_f: super.f,
    old_g: super.g,
  },
  WrapperDerived: WrapperBase + {
    Base+: { f: 5 },
  },
}

      </textarea>
    </div>
    <div class="bigarrow">➡</div>
    <div class="tab-window-output" id="oo-contrived-output">
      <div class="tab-header">
        <div class=selected onclick="tab_click(this, 'oo-contrived-json-output')">output.json</div>
      </div>
      <textarea readonly class="selected code-json" id="oo-contrived-json-output">
{
  "Derived": {
    "f": 5,
    "g": 105,
    "old_f": 2,
    "old_g": 105
  },
  "WrapperDerived": {
    "Base": {
      "f": 5,
      "g": 105
    }
  }
}

      </textarea>
    </div>
    <script>
      demo(
        'oo-contrived-input',
        {
          'oo-contrived-jsonnet': 'oo-contrived.jsonnet',
        },
        'oo-contrived.jsonnet',
        'oo-contrived-output',
        false,
        false
      );
    </script>
    <div style="clear: both"></div>
  </div>
</div>



<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        Let's make it more concrete by mixing deriving some cocktails that are quite similar from a
        template that draws out their similarities.  The <code>+</code> operator is actually
        implicit in these examples. In the common case where you write <code>foo + {
        </code>...<code> }</code>, i.e. the <code>+</code> is immediately followed by a
        <code>{</code>, then the <code>+</code> can be elided.  Try explicitly adding the + in the 4
        cases, below.
      </p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="inverse hgroup">
  <div class=hgroup-inline>
    <div class="tab-window-input" id="sours-oo-input">
      <div class="tab-header">
      </div>
      <textarea id=sours-oo-jsonnet>
local templates = import 'templates.libsonnet';

{
  // The template requires us to override
  // the 'spirit'.
  'Whiskey Sour': templates.Sour {
    spirit: 'Whiskey',
  },

  // Specialize it further.
  'Deluxe Sour': self['Whiskey Sour'] {
    // Don't replace the whole sweetner,
    // just change 'kind' within it.
    sweetener+: { kind: 'Gomme Syrup' },
  },

  Daiquiri: templates.Sour {
    spirit: 'Banks 7 Rum',
    citrus+: { kind: 'Lime' },
    // Any field can be overridden.
    garnish: 'Lime wedge',
  },

  "Nor'Easter": templates.Sour {
    spirit: 'Whiskey',
    citrus: { kind: 'Lime', qty: 0.5 },
    sweetener+: { kind: 'Maple Syrup' },
    // +: Can also add to a list.
    ingredients+: [
      { kind: 'Ginger Beer', qty: 1 },
    ],
  },
}

      </textarea>
      <textarea id=templates-libsonnet>
{
  // Abstract template of a "sour" cocktail.
  Sour: {
    local drink = self,

    // Hidden fields can be referred to
    // and overrridden, but do not appear
    // in the JSON output.
    citrus:: {
      kind: 'Lemon Juice',
      qty: 1,
    },
    sweetener:: {
      kind: 'Simple Syrup',
      qty: 0.5,
    },

    // A field that must be overridden.
    spirit:: error 'Must override "spirit"',

    ingredients: [
      { kind: drink.spirit, qty: 2 },
      drink.citrus,
      drink.sweetener,
    ],
    garnish: self.citrus.kind + ' twist',
    served: 'Straight Up',
  },
}

      </textarea>
    </div>
    <div class="bigarrow">➡</div>
    <div class="tab-window-output" id="sours-oo-output">
      <div class="tab-header">
        <div class=selected onclick="tab_output_click(this, 'sours-oo-json-output')">output.json</div>
      </div>
      <textarea readonly class="selected code-json" id="sours-oo-json-output">
{
  "Daiquiri": {
    "garnish": "Lime wedge",
    "ingredients": [
      {
        "kind": "Banks 7 Rum",
        "qty": 2
      },
      {
        "kind": "Lime",
        "qty": 1
      },
      {
        "kind": "Simple Syrup",
        "qty": 0.5
      }
    ],
    "served": "Straight Up"
  },
  "Deluxe Sour": {
    "garnish": "Lemon Juice twist",
    "ingredients": [
      {
        "kind": "Whiskey",
        "qty": 2
      },
      {
        "kind": "Lemon Juice",
        "qty": 1
      },
      {
        "kind": "Gomme Syrup",
        "qty": 0.5
      }
    ],
    "served": "Straight Up"
  },
  "Nor'Easter": {
    "garnish": "Lime twist",
    "ingredients": [
      {
        "kind": "Whiskey",
        "qty": 2
      },
      {
        "kind": "Lime",
        "qty": 0.5
      },
      {
        "kind": "Maple Syrup",
        "qty": 0.5
      },
      {
        "kind": "Ginger Beer",
        "qty": 1
      }
    ],
    "served": "Straight Up"
  },
  "Whiskey Sour": {
    "garnish": "Lemon Juice twist",
    "ingredients": [
      {
        "kind": "Whiskey",
        "qty": 2
      },
      {
        "kind": "Lemon Juice",
        "qty": 1
      },
      {
        "kind": "Simple Syrup",
        "qty": 0.5
      }
    ],
    "served": "Straight Up"
  }
}

      </textarea>
    </div>
    <script>
      demo(
        'sours-oo-input',
        {
          'sours-oo-jsonnet': 'sours-oo.jsonnet',
          'templates-libsonnet': 'templates.libsonnet',
        },
        'sours-oo.jsonnet',
        'sours-oo-output',
        false,
        false
      );
    </script>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        The key to making Jsonnet object-oriented is that the <code>self</code> keyword be "late
        bound".  In other words, <code>self.foo</code> can have its meaning altered by overriding it
        on the right hand side of a <code>+</code>.  This would not be the case in a simple "object
        merge" semantics of <code>+</code>, where <code>self.foo</code> would be fully evaluated to
        a concrete value before we did the <code>+</code>.  In the above example, the left hand side
        of the <code>+</code> is <code>templates.Sour</code> (the <code>+</code> is implicit) and
        the right hand side is an object that overrides <code>spirit</code>.  So in the
        <code>templates.Sour</code> definition (in <tt>templates.libsonnet</tt>) that causes the
        reference to <code>drink.spirit</code> in the ingredients list to return
        <code>"Whiskey"</code> rather than raise the error <code>'Must override "spirit"'</code>.
      </p>
      <p>
        Most of the abstraction in the above example could have been achieved with functions instead
        of object-orientation.  Indeed, last time we spoke about sours, we used functions for that
        very purpose.  In general, the choice of whether to use functions or object-orientation is
        quite a complex one, and can be driven as much by instinct as by anything else.  The most
        obvious difference is that with object-orientation, you can override any file from the
        resulting object, whereas with functions you can only pass arguments for the specific
        parameters of the function.  So, e.g., if the <code>templates.Sour</code> had been
        implemented as a function that did not parameterize the ingredients list in general way,
        then it would not have been possible to add that extra ingredient to form the Nor'Easter.
      </p>
      <p>
        So far, every example has used a literal object on the right hand side of the
        <code>+</code>.  This is consistent with the majority of object-oriented languages. But
        Jsonnet is more general in that is has <a
        href="http://www.bracha.org/oopsla90.pdf">mixins</a>.  A Mixin allows you to take some
        "overrides" and instead of just applying them to an existing object to get a new object, you
        can pass them around as a first class value and apply them to any object you want.  The
        following example shows mixins being used to modify cocktails in a general way:
      </p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="inverse hgroup">
  <div class=hgroup-inline>
    <div class="tab-window-input" id="mixins-input">
      <div class="tab-header">
      </div>
      <textarea id=mixins-jsonnet>
local sours = import 'sours-oo.jsonnet';

local RemoveGarnish = {
  // Not technically removed, but made hidden.
  garnish:: super.garnish,
};

// Make virgin cocktails
local NoAlcohol = {
  local Substitute(ingredient) =
    local k = ingredient.kind;
    local bitters = 'Angustura Bitters';
    if k == 'Whiskey' then [
      { kind: 'Water', qty: ingredient.qty },
      { kind: bitters, qty: 'tsp' },
    ] else if k == 'Banks 7 Rum' then [
      { kind: 'Water', qty: ingredient.qty },
      { kind: 'Vanilla Essence', qty: 'dash' },
      { kind: bitters, qty: 'dash' },
    ] else [
      ingredient,
    ],
  ingredients: [
    Substitute(i)
    for i in super.ingredients
  ],
};

local PartyMode = {
  served: 'In a plastic cup',
};

{
  'Whiskey Sour':
    sours['Whiskey Sour']
    + RemoveGarnish + PartyMode,

  'Virgin Whiskey Sour':
    sours['Whiskey Sour'] + NoAlcohol,

  'Virgin Daiquiri':
    sours.Daiquiri + NoAlcohol,

}

      </textarea>
      <textarea id=sours-oo-jsonnet2>
local templates = import 'templates.libsonnet';

{
  // The template requires us to override
  // the 'spirit'.
  'Whiskey Sour': templates.Sour {
    spirit: 'Whiskey',
  },

  // Specialize it further.
  'Deluxe Sour': self['Whiskey Sour'] {
    // Don't replace the whole sweetner,
    // just change 'kind' within it.
    sweetener+: { kind: 'Gomme Syrup' },
  },

  Daiquiri: templates.Sour {
    spirit: 'Banks 7 Rum',
    citrus+: { kind: 'Lime' },
    // Any field can be overridden.
    garnish: 'Lime wedge',
  },

  "Nor'Easter": templates.Sour {
    spirit: 'Whiskey',
    citrus: { kind: 'Lime', qty: 0.5 },
    sweetener+: { kind: 'Maple Syrup' },
    // +: Can also add to a list.
    ingredients+: [
      { kind: 'Ginger Beer', qty: 1 },
    ],
  },
}

      </textarea>
      <textarea id=templates-libsonnet2>
{
  // Abstract template of a "sour" cocktail.
  Sour: {
    local drink = self,

    // Hidden fields can be referred to
    // and overrridden, but do not appear
    // in the JSON output.
    citrus:: {
      kind: 'Lemon Juice',
      qty: 1,
    },
    sweetener:: {
      kind: 'Simple Syrup',
      qty: 0.5,
    },

    // A field that must be overridden.
    spirit:: error 'Must override "spirit"',

    ingredients: [
      { kind: drink.spirit, qty: 2 },
      drink.citrus,
      drink.sweetener,
    ],
    garnish: self.citrus.kind + ' twist',
    served: 'Straight Up',
  },
}

      </textarea>
    </div>
    <div class="bigarrow">➡</div>
    <div class="tab-window-output" id="mixins-output">
      <div class="tab-header">
        <div class=selected onclick="tab_output_click(this, 'mixins-json-output')">output.json</div>
      </div>
      <textarea readonly class="selected code-json" id="mixins-json-output">
{
  "Virgin Daiquiri": {
    "garnish": "Lime wedge",
    "ingredients": [
      [
        {
          "kind": "Water",
          "qty": 2
        },
        {
          "kind": "Vanilla Essence",
          "qty": "dash"
        },
        {
          "kind": "Angustura Bitters",
          "qty": "dash"
        }
      ],
      [
        {
          "kind": "Lime",
          "qty": 1
        }
      ],
      [
        {
          "kind": "Simple Syrup",
          "qty": 0.5
        }
      ]
    ],
    "served": "Straight Up"
  },
  "Virgin Whiskey Sour": {
    "garnish": "Lemon Juice twist",
    "ingredients": [
      [
        {
          "kind": "Water",
          "qty": 2
        },
        {
          "kind": "Angustura Bitters",
          "qty": "tsp"
        }
      ],
      [
        {
          "kind": "Lemon Juice",
          "qty": 1
        }
      ],
      [
        {
          "kind": "Simple Syrup",
          "qty": 0.5
        }
      ]
    ],
    "served": "Straight Up"
  },
  "Whiskey Sour": {
    "ingredients": [
      {
        "kind": "Whiskey",
        "qty": 2
      },
      {
        "kind": "Lemon Juice",
        "qty": 1
      },
      {
        "kind": "Simple Syrup",
        "qty": 0.5
      }
    ],
    "served": "In a plastic cup"
  }
}

      </textarea>
    </div>
    <script>
      demo(
        'mixins-input',
        {
          'mixins-jsonnet': 'mixins.jsonnet',
          'sours-oo-jsonnet2': 'sours-oo.jsonnet',
          'templates-libsonnet2': 'templates.libsonnet',
        },
        'mixins.jsonnet',
        'mixins-output',
        false,
        false
      );
    </script>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        Thank you for completing the Jsonnet tutorial! We hope you enjoyed the accompanying
        beverages.  At this point, you should be able to build concoctions of your own.  If you want
        to read about the Jsonnet language in greater and more systematic detail, we recommend the
        language <a href="/ref/language.html">reference</a>.
      </p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
    </div>
    <div style="clear: both"></div>
  </div>
</div>



<div class="inverse hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p class=footer>
        Except as noted, this content is licensed under Creative Commons Attribution 2.5.
      </p>
    </div>
  </div>
</div>

</body>

</html>

